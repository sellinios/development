"""Execution module for Athena brain."""

import logging
from typing import Dict, Any, Optional
from common.safe_eval import safe_eval, SafeEvalConfig


class ExecutionModule:
    """Handles execution of plans and expressions."""

    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.safe_eval_config = SafeEvalConfig(max_string_length=100000, max_power=1000)

    def execute_plan(self, plan: Dict[str, Any], context: Dict[str, Any]) -> Any:
        """
        Execute a plan generated by the reasoning engine.

        Args:
            plan: Execution plan
            context: Execution context

        Returns:
            Execution result
        """
        action_type = plan.get("action")

        if action_type == "calculate":
            return self._execute_calculation(plan, context)
        elif action_type == "explain":
            return self._execute_explanation(plan, context)
        elif action_type == "analysis":
            return self._execute_analysis(plan, context)
        elif action_type == "search":
            return self._execute_search(plan, context)
        elif action_type == "create":
            return self._execute_creation(plan, context)
        else:
            return self._execute_default(plan, context)

    def _execute_calculation(self, plan: Dict[str, Any], context: Dict[str, Any]) -> Any:
        """Execute a calculation plan."""
        expression = plan.get("expression")
        if expression:
            try:
                # First, try to parse and execute as Zeus code (handles pattern calls)
                from .athena_zeus_interface import ZeusInterface
                zeus = ZeusInterface()
                
                # If we have a runtime in context, pass variables
                variables = {}
                runtime = context.get("_runtime")
                if runtime and hasattr(runtime, 'scopes'):
                    # Extract variables from runtime scopes
                    for scope in runtime.scopes:
                        variables.update(scope)
                
                try:
                    result = zeus.execute_zeus_code(expression, variables)
                    # Ensure we return a value, not None
                    if result is not None:
                        return result
                except Exception as e:
                    # Fall back to safe_eval
                    self.logger.debug(f"Zeus evaluation failed, falling back to safe_eval: {e}")
                    pass
                
                # Otherwise use safe evaluator
                variables = context.get("variables", {})
                return safe_eval(expression, variables, self.safe_eval_config)
            except Exception as e:
                self.logger.warning(f"Failed to evaluate expression: {e}")
                error_msg = f"Error: Cannot evaluate '{expression}'"
                if "name" in str(e) and "not defined" in str(e):
                    # Extract the undefined name
                    import re
                    match = re.search(r"name '(\w+)' is not defined", str(e))
                    if match:
                        undefined_name = match.group(1)
                        error_msg = f"Error: '{undefined_name}' is not defined. Did you mean to teach it as a pattern first? Use: teach: {undefined_name} {{n}} -> {{n}} * X"
                return error_msg

        return "No expression to calculate"

    def _execute_explanation(self, plan: Dict[str, Any], context: Dict[str, Any]) -> str:
        """Execute an explanation plan."""
        explanation = plan.get("explanation", "")

        # Check if we need to format with context
        if "{" in explanation and "}" in explanation:
            try:
                return explanation.format(**context.get("variables", {}))
            except KeyError:
                pass

        return explanation
    
    def _execute_analysis(self, plan: Dict[str, Any], context: Dict[str, Any]) -> Any:
        """Execute an analysis plan."""
        # Get the original text from the plan
        nlp_result = plan.get("nlp_result", {})
        text = nlp_result.get("original_text", "")
        
        # Extract the sequence part (look for numbers separated by commas)
        import re
        
        # First try to find a comma-separated sequence
        sequence_match = re.search(r'sequence[^:]*:\s*([\d,\s]+)', text, re.IGNORECASE)
        if sequence_match:
            numbers_text = sequence_match.group(1)
            numbers = re.findall(r'\d+', numbers_text)
        else:
            # Fallback: look for any comma-separated numbers
            numbers_text = re.search(r'([\d,\s]+(?:,\s*\d+)+)', text)
            if numbers_text:
                numbers = re.findall(r'\d+', numbers_text.group(1))
            else:
                # Last resort: get all numbers
                numbers = re.findall(r'\d+', text)
        
        if numbers:
            sequence = [int(n) for n in numbers]
            
            # Debug output
            self.logger.info(f"Analyzing sequence: {sequence}")
            
            # Check if it's a Fibonacci sequence
            if len(sequence) >= 3:
                is_fibonacci = True
                for i in range(2, len(sequence)):
                    if sequence[i] != sequence[i-1] + sequence[i-2]:
                        is_fibonacci = False
                        break
                
                if is_fibonacci:
                    # Generate next 3 Fibonacci numbers
                    next_nums = []
                    a, b = sequence[-2], sequence[-1]
                    for _ in range(3):
                        c = a + b
                        next_nums.append(c)
                        a, b = b, c
                    
                    return f"This is a Fibonacci sequence. The next 3 elements are: {', '.join(map(str, next_nums))}"
            
            # Check for arithmetic progression
            if len(sequence) >= 2:
                diff = sequence[1] - sequence[0]
                is_arithmetic = True
                for i in range(2, len(sequence)):
                    if sequence[i] - sequence[i-1] != diff:
                        is_arithmetic = False
                        break
                
                if is_arithmetic:
                    next_nums = []
                    last = sequence[-1]
                    for _ in range(3):
                        last += diff
                        next_nums.append(last)
                    
                    return f"This is an arithmetic sequence with difference {diff}. The next 3 elements are: {', '.join(map(str, next_nums))}"
            
            # Check for geometric progression
            if len(sequence) >= 2 and sequence[0] != 0:
                ratio = sequence[1] / sequence[0]
                is_geometric = True
                for i in range(2, len(sequence)):
                    if sequence[i-1] != 0 and sequence[i] / sequence[i-1] != ratio:
                        is_geometric = False
                        break
                
                if is_geometric:
                    next_nums = []
                    last = sequence[-1]
                    for _ in range(3):
                        last = int(last * ratio)
                        next_nums.append(last)
                    
                    return f"This is a geometric sequence with ratio {ratio}. The next 3 elements are: {', '.join(map(str, next_nums))}"
        
        return "Unable to determine the pattern in this sequence. Please provide more context or examples."

    def _execute_search(self, plan: Dict[str, Any], context: Dict[str, Any]) -> Any:
        """Execute a search plan."""
        query = plan.get("query", "")
        search_type = plan.get("search_type", "general")

        # Access available context for searching
        variables = context.get("variables", {})
        functions = context.get("functions", {})
        patterns = context.get("patterns", {})
        history = context.get("history", [])

        results = []

        # Search in variables
        if search_type in ["general", "variable", "all"]:
            for var_name, var_value in variables.items():
                if query.lower() in var_name.lower() or query.lower() in str(var_value).lower():
                    results.append(
                        {
                            "type": "variable",
                            "name": var_name,
                            "value": var_value,
                            "match_score": self._calculate_match_score(
                                query, var_name, str(var_value)
                            ),
                        }
                    )

        # Search in functions
        if search_type in ["general", "function", "all"]:
            for func_name, func_def in functions.items():
                if query.lower() in func_name.lower():
                    results.append(
                        {
                            "type": "function",
                            "name": func_name,
                            "definition": func_def,
                            "match_score": self._calculate_match_score(query, func_name),
                        }
                    )

        # Search in patterns
        if search_type in ["general", "pattern", "all"]:
            for pattern_name, pattern_def in patterns.items():
                if query.lower() in pattern_name.lower():
                    results.append(
                        {
                            "type": "pattern",
                            "name": pattern_name,
                            "definition": pattern_def,
                            "match_score": self._calculate_match_score(query, pattern_name),
                        }
                    )

        # Search in history
        if search_type in ["general", "history", "all"] and history:
            for i, entry in enumerate(history[-10:]):  # Search last 10 entries
                if query.lower() in str(entry).lower():
                    results.append(
                        {
                            "type": "history",
                            "index": len(history) - 10 + i,
                            "entry": entry,
                            "match_score": self._calculate_match_score(query, str(entry)),
                        }
                    )

        # Sort results by match score
        results.sort(key=lambda x: x.get("match_score", 0), reverse=True)

        # Format results
        if not results:
            return f"No results found for '{query}'"
        elif len(results) == 1:
            result = results[0]
            if result["type"] == "variable":
                return f"{result['name']} = {result['value']}"
            elif result["type"] == "function":
                return f"Function {result['name']}: {result.get('definition', {}).get('parameters', [])}"
            elif result["type"] == "pattern":
                return (
                    f"Pattern {result['name']}: {result.get('definition', {}).get('template', '')}"
                )
            else:
                return f"Found in history: {result['entry']}"
        else:
            output = f"Found {len(results)} results for '{query}':\n"
            for i, result in enumerate(results[:5]):  # Show top 5
                if result["type"] == "variable":
                    output += f"  {i+1}. Variable: {result['name']} = {result['value']}\n"
                elif result["type"] == "function":
                    output += f"  {i+1}. Function: {result['name']}\n"
                elif result["type"] == "pattern":
                    output += f"  {i+1}. Pattern: {result['name']}\n"
                else:
                    output += f"  {i+1}. History: {str(result['entry'])[:50]}...\n"
            if len(results) > 5:
                output += f"  ... and {len(results) - 5} more results\n"
            return output.rstrip()

    def _execute_creation(self, plan: Dict[str, Any], context: Dict[str, Any]) -> Any:
        """Execute a creation plan."""
        create_type = plan.get("create_type", "")
        parameters = plan.get("parameters", {})

        if create_type == "variable":
            # Create/update a variable
            name = parameters.get("name")
            value = parameters.get("value")
            if name:
                # Add to context for future reference
                if "variables" not in context:
                    context["variables"] = {}
                context["variables"][name] = value
                return f"Created variable: {name} = {value}"
            else:
                return "Error: Variable name not specified"

        elif create_type == "function":
            # Create a function definition
            name = parameters.get("name")
            params = parameters.get("parameters", [])
            body = parameters.get("body", "")

            if name:
                func_def = {"type": "function", "name": name, "parameters": params, "body": body}

                # Add to context
                if "functions" not in context:
                    context["functions"] = {}
                context["functions"][name] = func_def

                return f"Created function: {name}({', '.join(params)})"
            else:
                return "Error: Function name not specified"

        elif create_type == "pattern":
            # Create a pattern
            name = parameters.get("name")
            template = parameters.get("template")
            implementation = parameters.get("implementation")

            if name and template:
                pattern_def = {
                    "type": "pattern",
                    "name": name,
                    "template": template,
                    "implementation": implementation,
                }

                # Add to context
                if "patterns" not in context:
                    context["patterns"] = {}
                context["patterns"][name] = pattern_def

                return f"Created pattern: {name}"
            else:
                return "Error: Pattern name or template not specified"

        elif create_type == "list":
            # Create a list
            name = parameters.get("name")
            elements = parameters.get("elements", [])

            if name:
                if "variables" not in context:
                    context["variables"] = {}
                context["variables"][name] = elements
                return f"Created list: {name} with {len(elements)} elements"
            else:
                # Return anonymous list
                return elements

        elif create_type == "dict" or create_type == "dictionary":
            # Create a dictionary
            name = parameters.get("name")
            items = parameters.get("items", {})

            if name:
                if "variables" not in context:
                    context["variables"] = {}
                context["variables"][name] = items
                return f"Created dictionary: {name} with {len(items)} items"
            else:
                # Return anonymous dict
                return items

        elif create_type == "class":
            # Create a class definition
            name = parameters.get("name")
            attributes = parameters.get("attributes", {})
            methods = parameters.get("methods", {})

            if name:
                class_def = {
                    "type": "class",
                    "name": name,
                    "attributes": attributes,
                    "methods": methods,
                }

                # Add to context
                if "classes" not in context:
                    context["classes"] = {}
                context["classes"][name] = class_def

                return f"Created class: {name}"
            else:
                return "Error: Class name not specified"

        else:
            # Unknown creation type
            return f"Unknown creation type: {create_type}. Supported types: variable, function, pattern, list, dict, class"

    def _execute_default(self, plan: Dict[str, Any], context: Dict[str, Any]) -> Any:
        """Execute a default plan."""
        # Try to find any executable content
        if "result" in plan:
            return plan["result"]
        elif "explanation" in plan:
            return plan["explanation"]
        elif "message" in plan:
            return plan["message"]
        else:
            return "I need more information to complete this request."

    def validate_expression(self, expression: str) -> bool:
        """Validate if an expression is safe to execute."""
        try:
            # Try parsing with safe evaluator
            safe_eval(expression, {}, self.safe_eval_config)
            return True
        except Exception:
            return False

    def _calculate_match_score(self, query: str, *texts: str) -> float:
        """Calculate how well a query matches given texts."""
        query_lower = query.lower()
        score = 0.0

        for text in texts:
            if not text:
                continue

            text_lower = text.lower()

            # Exact match
            if query_lower == text_lower:
                score += 1.0
            # Contains query
            elif query_lower in text_lower:
                score += 0.7
            # Query contains text
            elif text_lower in query_lower:
                score += 0.5
            # Partial word match
            else:
                query_words = set(query_lower.split())
                text_words = set(text_lower.split())
                common_words = query_words.intersection(text_words)
                if common_words:
                    score += 0.3 * len(common_words) / max(len(query_words), len(text_words))

        return min(score, 1.0)  # Cap at 1.0
